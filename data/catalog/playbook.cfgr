module NoETLPlaybook;
{*
    This module defines the grammar for the NoETL Playbook format.
    The playbook is a structured document that describes tasks, actions, and workflows.
    It is used to define and execute data processing workflows in a NoETL friendly environment.
*}

(* The NoETL Playbook grammar is defined using EBNF syntax. *)

(* The playbook consists of metadata, environment, context, workbook, and workflow sections. *)
(* Each section has its own structure and rules. *)

(* NoETL Playbook EBNF Grammar *)

(* The grammar is defined using Extended Backus-Naur Form (EBNF) syntax. *)

(* A playbook consists of metadata, environment, context, workbook, and workflow. *)
(* Each section is defined with its own structure and rules. *)

(* The playbook rule is the top-level structure, consists of 5 main parts in sequence. *)

playbook =
    metadata ,
    environment ,
    context ,
    workbook ,
    workflow
;

(* metadata rule defines the playbook's identity and location. *)

metadata =
    'apiVersion' ':' string ,
    'kind' ':' 'Playbook' ,
    'name' ':' string ,
    'path' ':' string
;

(* environment rule defines the configuration inputs for the playbook. *)

environment =
    'environment' ':' '{' { key_value_entry } '}'
;

(* context rule describes the runtime state and step statuses. *)

context =
    'context' ':' '{' ,
        { key_value_entry } ,
        'jobId' ':' expression ,
        'steps' ':' '[' { step_status } ']' ,
        'state' ':' identifier ,
        'results' ':' '{' '}' ,
    '}'
;

step_status =
    'step' ':' identifier ,
    'status' ':' identifier
;


(* workbook rule defines named tasks composed of units. *)

workbook =
    'workbook' ':' '[' { task_definition } ']'
;

task_definition =
    [ loop_clause ] ,
    'task' ':' identifier ,
    [ 'mode' ':' ( 'sequential' | 'parallel' ) ] ,
    [ loop_clause ] ,
    'run' ':' '[' { action_definition } ']'
;

(* action_definition rule defines the executable units. An action is the smallest executable unit. *)

action_definition =
    'action' ':' identifier ,
    [ 'mode' ':' ( 'sequential' | 'parallel' ) ] ,
    'method' ':' identifier ,
    'name' ':' quoted_template ,
    'desc' ':' string ,
    'endpoint' ':' expression ,
    'params' ':' '{' { key_value_entry } '}' ,
    [ loop_clause ] ,
    [ 'run' ':' '[' { action_definition } ']' ]
;

key_value_entry =
    identifier ':' value
;

(* loop_clause rule defines the iteration structure for for units or tasks, and steps. *)

loop_clause =
    'loop' ':' string_expression
;

(* workflow rule orchestrates the execution of tasks, actions and transitions in a defined order. *)

workflow =
    'workflow' ':' '[' { workflow_step } ']'
;

workflow_step =
    'step' ':' identifier ,
    [ 'mode' ':' ( 'sequential' | 'parallel' ) ] ,
    [ 'when' ':' expression ] ,
    [ loop_clause ] ,
    'run' ':' '[' { step_run_item } ']' ,
    [ 'next' ':' '[' { next_clause } ']' ]
;


step_run_item =
    ( 'task' ':' identifier | 'action' ':' identifier | 'playbook' ':' identifier ) ,
    [ 'until' ':' expression ]
;

(* next_clause rule defines the conditions for transitioning to the next steps. *)

next_clause =
    'when' ':' expression ,
    'then' ':' '[' { identifier } ']'
;


(* The value and expression rules. *)

value =
    literal | quoted_template | list | dictionary
;

expression =
    string_expression
;

quoted_template =
    '"' , { template_char } , '"'
;


string_expression =
    { character }
;

list =
    '[' [ value { ',' value } ] ']'
;

dictionary =
    '{' [ key_value_entry { ',' key_value_entry } ] '}'
;

(* Rule of primitives. *)


literal =
    string | number | boolean
;

string =
    '"' , { character } , '"'
;


number =
    [ '-' ] , digit , { digit }
;

boolean =
    'true' | 'false'
;

identifier =
    letter , { letter | digit | '_' }
;

letter =
    'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' |
    'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' |
    'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' |
    'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z'
;

digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';

template_char =
    character | '{' | '}' | '.' | '_' | '[' | ']' | '(' | ')' | '+' | '-' | '/' | '*' | ' '
;

operator = '==' | '!=' | '<' | '>' | '<=' | '>=' | 'and' | 'or' | '.';

character = unicode_safe_char;

(* unicode_safe_char is any valid Unicode character excluding double-quote (\") and control characters U+0000 to U+001F and U+007F. *)
unicode_safe_char =
    ? any Unicode character except double-quote (\") and control characters U+0000 to U+001F and U+007F ?