= NoETL Workflow Execution System Documentation

== Architecture Overview:

The NoETL system is a workflow execution engine that caters to automating the execution of tasks as defined by a specific playbook. The system incorporates a publisher-subscriber pattern for transmitting commands and receiving events using NATS messaging system, leveraging an Erlang-inspired, plugin-based architecture.

== Plugin-Based Workflow and Erlang Design Principles:

NoETL embraces several of Erlang's fundamental concepts in its architecture:

* Everything is a Plugin: In NoETL, functional units are treated as plugins, analogous to how every operation is encapsulated within a process in Erlang. Each plugin corresponds to a Docker image that can be executed as a service or a job within a Kubernetes environment. The term 'plugin' in NoETL playbooks serves as an alias to these Docker image.

* Strong Isolation of Plugins: Each plugin in NoETL operates independently and isolated from others, similar to Erlang's process isolation.

* Lightweight Plugin Management: NoETL allows for the dynamic and efficient creation and destruction of plugin instances, permitting a scalable system architecture.

* Message Passing as Core Interaction: Communication between plugins in NoETL is achieved through message passing via NATS streams, ensuring accurate and directed messaging.

* No Shared Resources Between Plugins: Plugins operate without shared resources, promoting isolated execution and reducing resource contention.

* Resilience and Reliability: NoETL is designed to be robust and reliable, with each plugin designed to perform its designated tasks effectively or fail gracefully.

== Workflow:

Workflows in NoETL are treated as playbooks – a YAML script that orchestrates the execution of tasks in a pre-defined sequence. Each playbook describes a sequence of tasks, with each task referring to a specific plugin, which gets executed as a step within the task.

[[tasks-and-steps]]
== Tasks and Steps

Tasks are the fundamental operational elements within a playbook, and they consist of numerous sequential steps. These tasks contain multiple steps, and each step invokes the execution of the corresponding plugin module.

The design model follows these principles:

* Tasks can be executed in parallel, promoting efficiency in playbook execution.
* The steps within a task are executed sequentially. Each step in a task must complete before the next one starts.
* The most atomic operation in NoETL is the 'step.' Each 'step' specifically refers to a plugin module that is executed.

In essence, a playbook is a collection of tasks, and each task is a sequence of steps. This architecture allows for complex workflows to be broken down into manageable, isolated operations which can run concurrently and efficiently.

== Events and Commands:

Events and commands are integral to the operation of NoETL, driving the control flow across the system.

== Communication Among Events and Commands:

In NoETL, commands and events communicate with each other using NATS. Commands trigger the execution of tasks in a playbook. Once these tasks (or actions) are completed, an event is published, signaling the completion of the task. This model of communication keeps the execution of a playbook in a highly decoupled and fault-tolerant manner.

== NATS Communication Subjects:

The subjects used in NoETL are unique and structured to provide contextual information about the operation being performed:

* Command subjects: `command.<plugin_name>.<workflow_id>.<step_id>`
* Event subjects: `event.<plugin_name>.<workflow_id>.<step_id>`

In both cases, `<plugin_name>` denotes the plugin service that is the intended recipient of the command or responsible for the event. `<workflow_id>` is the unique identifier of the workflow instance, and `<step_id>` represents the unique identifier of a step within a task in the workflow.```

== Mini-Plugin Architecture:

In addition to the distributed nature of tasks, the NoETL system architecture includes several application services considered as plugins. Each service encapsulates a facet of the system's functionality:

. `Command API plugin`: Exposes an API endpoint for receiving and managing commands from various external clients. It validates these commands and registers them to the system.

. `Event API plugin`: Provides an API endpoint for event data management. It keeps track of events deriving from workflow engine and writes them into an event log database. It also supports querying and subscribing to event data updates.

. `Dispatcher API plugin`: Primarily responsible for triggering dispatching actions. It subscribes to Event API for specific events, interpretes these events to schedule new commands, manages task queues ensuring efficient execution of commands.

Please note that these plugin services communicate with each other, invoking commands (tasks) and handling events primarily using NATS messaging. These commands are driven by playbooks that are written in YAML specifying sequence of tasks corresponding to Docker images acting as plugins. The execution environment of these plugins is typically Kubernetes, giving a high degree of flexibility and scalability to the workflow execution system.

The command registration and execution process in NoETL is both coordinated and distributed – APIs, Dispatcher, and plugins work harmoniously to carry out tasks, communicate state, and ensure the resilience of the whole system. This architecture promotes scalability, robustness and fault-tolerance, key to a reliable workflow execution system.
